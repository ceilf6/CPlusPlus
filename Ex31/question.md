---

## 练习 28 —— 事件（Évènements）—— 多态（Polymorphisme）

### 问题 1 —— 多态

执行以下指令：

```cpp
Evt1j e1(Date(4,10,1957),"Spoutnik");
Evt1j e2(Date(11,6,2013),"Shenzhou");
Evt1jDur e3(Date(11,6,2013),"长征火箭发射",Horaire(17,38),Duree(0,10));
Rdv e4(Date(11,4,2013),"UV 会议",Horaire(17,30),Duree(60),
       "UV 演讲者","办公室");

e1.afficher(); e2.afficher(); e3.afficher(); e4.afficher();

Evt1j* pt1=&e1; 
Evt1j* pt2=&e2; 
Evt1j* pt3=&e3; 
Evt1j* pt4=&e4;

pt1->afficher(); 
pt2->afficher(); 
pt3->afficher(); 
pt4->afficher();
```

1. 你观察到了什么？
   请确认**多态是否被正确实现**；如果没有，请修改程序以保证多态生效。
2. **重载（一次或多次）运算符 `operator<<`**，使其可以与 `std::ostream` 对象一起使用，并且适用于**任意事件对象**。

---

### 问题 2 —— 多态与析构

在类 **Evt1j、Evt1jDur 和 Rdv** 的构造函数中，向 `cout` 输出一条信息，例如：

> “构造了一个 X 类的对象”。

在这些类中定义析构函数，并在析构函数中向 `cout` 输出类似信息：

> “销毁了一个 X 类的对象”。

然后执行以下指令：

```cpp
Rdv* pt5 = new Rdv(Date(12,11,2013),"UV 会议",
                   Horaire(17,30),Duree(60),
                   "UV 演讲者","办公室");
pt5->afficher();
delete pt5;

Evt1j* pt6 = new Rdv(Date(12,11,2013),"UV 会议",
                     Horaire(17,30),Duree(60),
                     "UV 演讲者","办公室");
pt6->afficher();
delete pt6;
```

你观察到了什么？
如有必要，请**修正存在的问题**。

---

## 练习 29 —— 多态与异构存储

现在希望定义一个 **Agenda（日程表）** 类，用来存储事件。

1. 实现一个 `Agenda` 类，使其可以管理**任意类型的事件**（`Evt1j`、`Evt1jDur`、`Rdv`）。
   为此，使用一个**标准容器**，其中存储的是指向 `Evt1j` 的指针。
   同时，**禁止对 `Agenda` 对象进行复制或赋值**。
2. 定义运算符

   ```cpp
   Agenda& Agenda::operator<<(Evt1j& e)
   ```

   用于向日程表中添加一个事件。
   仅保存传入事件的**地址**，**不进行复制**。
3. `Agenda` 类与事件类之间是什么类型的关联关系？
   相应地补全**第 1 题中的类图**。
4. 定义成员函数

   ```cpp
   void afficher(std::ostream& f = std::cout) const
   ```

   用于显示 `Agenda` 对象中的所有事件。

---

## 练习 30 —— 事件 —— 抽象类与泛化

现在假设某些事件可能持续多天（会议、节日、庆典等）。
因此希望定义一个 **EvtPj（多天事件）** 类。

在此之前，需要对 `Evt1j` 所表示的概念进行泛化，引入一个新的类 **Evt**，
该类**不受天数限制**：

* 一个 `Evt1j` 对象是一个 `Evt`，具有**单一天期**；
* 一个 `EvtPj` 对象是一个 `Evt`，具有**开始日期和结束日期**。

1. 实现一个**抽象类 `Evt`**，其中包含**纯虚函数** `afficher()`。
2. 验证 `Evt` 类**不能被实例化**。
3. 修改之前的继承结构，以考虑这一新类。
4. 将属性 `sujet（主题）` 提升到 `Evt` 类中。
5. 修改 `Evt1j`、`Agenda` 以及 `operator<<` 函数，使其适应这些变化
   （`Agenda` 现在应存储 `Evt` 对象）。
6. 定义 `EvtPj`（多天事件）类。
7. 修改类图，使其反映所有这些改动。

---

## 练习 31 —— 事件 —— 设计模式

### 问题 1 —— 迭代器（Iterator）设计模式

为 `Agenda` 类实现 **迭代器设计模式**，
以便顺序遍历日程表中的事件。
实现的迭代器必须是**双向的**（可以在序列中前进和后退）。

---

### 问题 2 —— 原型（Prototype）设计模式

现在让 `Agenda` 对象**对其事件负责**，
即对传入的事件对象进行**动态复制**。

* 此时，`Agenda` 类与事件类之间属于哪种关联关系？
* 请补充并修改类图以反映这一变化。

---