没有 virtual 时，C++在编译期只看 “指针/引用的静态类型”
有 virtual 时，C++在运行期根据 “对象的真实类型” 通过虚函数表vtable 进行动态分派（就像：一击命中JS原型链中对应的，甚至比链式找更快，因为链式需要O(n)查找但是虚函数表直接O(1)分派就好）

1. 用 virtual 才有多态
    如果 Evt1j::afficher() 不是 virtual 的话
    编译器会按照 指针静态类型 调用，像 Evt1j* pt4 = &e4; 然后 pt4->afficher() 只会调用 Evt1j::afficher()
    当 afficher 开启 virtual 后，运行时会根据对象真实类型动态绑定
    ```
    virtual void afficher(...) const;
    ```

2. operator 要靠虚函数实现
    因为需要 std::ostream << 任意事件对象
    如果只是简单的非多态输出函数会丢信息
    所以正确的应该是 调virtual
    ```
    std::ostream& operator<<(std::ostream& os, const Evt1j& e) {
        e.afficher(os);  // 调 virtual
        return os;
    }
    ```
    无论传入的是 Evt1j / Evt1Dur ...都会走各自的 afficher

3. delete
    如果 Evt1j 的析构函数不是 virtual
    delete 只会调用 Evt1j::~Evt1j()
    不会调用 Rdv::~Rdv() / Evt1Dur::~Evt1Dur() ...
    导致内存泄漏、未完整析构

    当基类析构函数改为 virtual ~Evt1j() 后
    delete 会按真实类型调用完整析构链：
    ~Rdv() → ~Evt1jDur() → ~Evt1j()