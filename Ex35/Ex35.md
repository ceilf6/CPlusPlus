题目要求开发一组类，用于存储任意类型的对象
    容器：能包含其他对象的类
希望每一种容器都有统一的使用方式，因此，需要为所有容器定义公共接口

- 容器大小：容器中包含的对象数量
- 空容器：当容器中不包含任何对象时
- 对象索引从 0 开始
- 用 T 表示容器中所存储的对象类型


Container<T>
    抽象基类（模版类）
    定义统一接口
    用 Template Method 减少纯虚函数
Vector<T>
    具体容器
    内部用 T* tab 动态数组实现存储逻辑
          ┌──────────────────────────────┐
          │        Container<T>           │
          │        (abstract)             │
          ├──────────────────────────────┤
          │ + size() : size_t             │
          │ + empty() : bool              │
          │ + element(i) : T&             │
          │ + element(i) const : const T& │
          │ + front() : T&                │
          │ + front() const : const T&    │
          │ + back() : T&                 │
          │ + back() const : const T&     │
          │ + push_back(x) : void         │
          │ + pop_back() : void           │
          │ + clear() : void              │
          ├──────────────────────────────┤
          │ # at(i) : T&                  │  ← hook methods
          │ # at(i) const : const T&      │
          │ # doPushBack(x) : void        │
          │ # doPopBack() : void          │
          │ # doClear() : void            │
          │ # getSize() : size_t           │
          └──────────────▲───────────────┘
                         │
                         │ inheritance
                         │
          ┌──────────────────────────────┐
          │           Vector<T>           │
          ├──────────────────────────────┤
          │ - tab : T*                    │
          │ - sz  : size_t                │
          │ - cap : size_t                │
          ├──────────────────────────────┤
          │ + Vector(...)                 │
          │ + ~Vector()                   │
          │ + operator[](i) : T&          │
          │ + operator[](i) const : const T& │
          ├──────────────────────────────┤
          │ # at(i) : T&                  │
          │ # at(i) const : const T&      │
          │ # doPushBack(x) : void        │
          │ # doPopBack() : void          │
          │ # doClear() : void            │
          │ # getSize() : size_t           │
          └──────────────────────────────┘

1. 泛型实现：（TS是写在旁边，C++是写在上方）
    ```
    template <typename T>
    class Container
    ```
    ```
    template <typename T>
    class Vector : public Container<T>
    ```

2. 模版方法模式，在 Container<T> 中定义了一系列骨架
    ```
    T &element 等等
    ```
    具体行为由子类完成

3. 抽象类（模版方法模式-基类对公共算法的实现） + 最少纯虚函数（具体数据结构差异通过受保护的虚函数hook方法由子类自行适配）
    只有最底层存储相关方法是虚函数，即 Container<T> 中 protected 的 6个hook方法（父类预留、子类填充的可变点），这些方法 Container 不知道怎么实现、用户不能直接调用，完全依赖具体存储结构
    公共逻辑全部复用：size / empty / element / front / back / push_back / pop_back / clear 等

4. 动态内存管理 - 容器 Vector 中
    1. 在堆上分配一块连续内存，返回指针 T*
    ```
    tab = new T[cap]
    ```
    2. 释放动态内存
    ```
    ~Vector() {
        delete[] tab;
    }
    ```
    3. 扩容 Vector::resize()
    ```
    void resize(size_t newCap) {
        T* newTab = new T[newCap];  // 1. 分配新内存

        for(size_t i = 0; i < sz; ++i)
            newTab[i] = tab[i]; // 2. 拷贝数据
        
        delete[] tab; // 3. 释放旧内存
        tab = newTab; // 4. 指针切换
        cab = newCap;
    }
    ```
    4. 深拷贝：递归拷贝内容，而不是拷贝指针
    ```
    Vector(const Vector& other)
        : tab(new T[other.cap]), sz(other.sz), cap(other.cap) {
        for (size_t i = 0; i < sz; ++i)
            tab[i] = other.tab[i];
    }
    ```
    5. 赋值
    ```
    Vector& operator=(const Vector& other) {
        if (this != &other) {
            delete[] tab;                     // 1. 释放原先管理的旧内存
            cap = other.cap;
            sz = other.sz;
            tab = new T[cap];                 // 2. 赋值新
            for (size_t i = 0; i < sz; ++i)
                tab[i] = other.tab[i];
        }
        return *this;
    }
    ```

5. const 成员函数
    const T&

6. 异常机制
    C++ 中发现错误时throw然后沿调用栈向上传播-自动退栈
        如果没有catch进行处理就会程序终止 std::terminate
    
    1. 自定义异常类型
    ```
    class ContainerException : public std::exception
    ```
    2. 在接口处进行条件检查并 throw 
    例如越界 / 空容器
    3. 在 main 调用处 try-catch 捕获并处理