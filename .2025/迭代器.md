# 通过 while循环不断迭代指针 find_if 找到所有符号要求的元素
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

struct IsGreater {
    int threshold;
    IsGreater(int t) : threshold(t) {}

    // 带 1 个参数的函数对象
    bool operator()(int n) const {
        return n > threshold;
    }
};

int main() {
    std::vector<int> nums = {};
    auto it = nums.begin();
    while ((it = std::find_if(it, nums.end(), IsGreater(7))) != nums.end()) {
        // 当前的结果作为下一次的开始
        std::cout << *it << std::endl; // 输出语句：或者用 print, afficher
        ++it; // 移动到下一个位置继续找
    }
    return 0;
}
```

STL迭代器的基本操作
- ++it 前置递增
- *it 解引用
- it1 == it2 / != 比较

const_iterator 是只读迭代器：不能修改容器的内容

容器的 begin() 和 end() 方法

例如 Ex37/main.cpp 中 Vector 内的 iterator

# 迭代器
迭代器作为一种设计模式，用于提供一种统一的方式来访问容器中的元素，而不暴露容器的内部结构
核心思想：将 “如何遍历” 与 “数据结构” 分离

本次考试应该不会直接简单的使用 begin 和 end 而是要更加聚焦底层

## 基本操作
解引用 - 访问元素
*it // 获取元素引用
it->member // 访问成员

begin() 指向第一个元素位置
end() 指向最后一个元素之后的位置，end是一个哨兵，不能解引用

  vector<int> vec = {1, 2, 3}; // iterator - 可读可写                                                                                           
  vector<int>::iterator it = vec.begin();                                                                          
  *it = 10;  // OK，可以修改                                                                                       
                                                                                                                   
  // const_iterator - 只读                                                                                         
  vector<int>::const_iterator cit = vec.begin();                                                                   
  *cit = 10;  // 错误！不能修改                                                                                    
  cout << *cit;  // OK，可以读取 

1. 基于连续内存（Vector）                                                                                        
                                                                                                                   
  template<typename T>                                                                                             
  class Vector {                                                                                                   
      class iterator {                                                                                             
      private:                                                                                                     
          T* ptr;  // 内部就是一个指针                                                                             
                                                                                                                   
      public:                                                                                                      
          // 构造函数                                                                                              
          explicit iterator(T* p = nullptr) : ptr(p) {}                                                            
                                                                                                                   
          // 解引用                                                                                                
          T& operator*() const { return *ptr; }                                                                    
                                                                                                                   
          // 前置递增                                                                                              
          iterator& operator++() {                                                                                 
              ++ptr;                                                                                               
              return *this;                                                                                        
          }                                                                                                        
                                                                                                                   
          // 后置递增                                                                                              
          iterator operator++(int) {                                                                               
              iterator temp = *this;                                                                               
              ++ptr;                                                                                               
              return temp;                                                                                         
          }                                                                                                        
                                                                                                                   
          // 比较                                                                                                  
          bool operator==(const iterator& other) const {                                                           
              return ptr == other.ptr;                                                                             
          }                                                                                                        
                                                                                                                   
          bool operator!=(const iterator& other) const {                                                           
              return ptr != other.ptr;                                                                             
          }                                                                                                        
                                                                                                                   
          // 随机访问（可选）                                                                                      
          iterator operator+(int n) const {                                                                        
              return iterator(ptr + n);                                                                            
          }                                                                                                        
                                                                                                                   
          // 箭头操作符                                                                                            
          T* operator->() const {                                                                                  
              return ptr;                                                                                          
          }                                                                                                        
      };                                                                                                           
                                                                                                                   
      iterator begin() { return iterator(data); }                                                                  
      iterator end() { return iterator(data + vecSize); }                                                          
  };                                                                                                               
                                                                                                                   
  2. 基于链表（Stack）                                                                                             
                                                                                                                   
  template<typename T>                                                                                             
  class Stack {                                                                                                    
      struct Node {                                                                                                
          T data;                                                                                                  
          Node* next;                                                                                              
      };                                                                                                           
                                                                                                                   
      class iterator {                                                                                             
      private:                                                                                                     
          Node* current;  // 指向当前节点                                                                          
                                                                                                                   
      public:                                                                                                      
          explicit iterator(Node* node = nullptr) : current(node) {}                                               
                                                                                                                   
          T& operator*() const {                                                                                   
              return current->data;                                                                                
          }                                                                                                        
                                                                                                                   
          iterator& operator++() {                                                                                 
              if (current) {                                                                                       
                  current = current->next;                                                                         
              }                                                                                                    
              return *this;                                                                                        
          }                                                                                                        
                                                                                                                   
          bool operator==(const iterator& other) const {                                                           
              return current == other.current;                                                                     
          }                                                                                                        
                                                                                                                   
          bool operator!=(const iterator& other) const {                                                           
              return current != other.current;                                                                     
          }                                                                                                        
      };                                                                                                           
                                                                                                                   
      iterator begin() { return iterator(topNode); }                                                               
      iterator end() { return iterator(nullptr); }                                                                 
  };