![](./assets/Ex75/image.png)

![](./assets/Ex75/image%20copy.png)

![](./assets/Ex75/image%20copy%202.png)

![](./assets/Ex75/image%20copy%203.png)

![](./assets/Ex75/image%20copy%204.png)

![](./assets/Ex75/image%20copy%205.png)

![](./assets/Ex75/image%20copy%206.png)

练习 75 —— 关系（Relations）

在本题中，我们要用 C++ 定义一些类来操作“关系”。
为了简化问题，只考虑有限集合之间的二元关系。

⸻

一、数学背景说明

关系（Relation）

设有两个集合 E 和 F。
E 与 F 之间的一个二元关系 R 是集合
R \subseteq E \times F = \{(a,b)\ |\ a \in E,\ b \in F\}
	•	E 称为关系的出发集合（source，起始集合）
	•	F 称为关系的到达集合（destination，终止集合）

一个关系可以用列举所有属于该关系的有序对 (a,b) 的方式来定义（外延定义）。

⸻

示例 1
	•	E = \{0,1,2,3,4,5,6,7,8,9\}
	•	F = \{a,e,i,o,u\}

定义关系 R：
若元音字母 b 出现在数字 a 的法文拼写中，则 aRb。

例如：
	•	4 的法文是 quatre，包含 u, a, e
	•	因此 (4,u), (4,a), (4,e) 属于关系 R

最终：
R = \{(0,e),(0,o),(1,u),(2,e),(2,u),(3,o),(3,i),(4,u),(4,a),(4,e),(5,i),(6,i),(7,e),(8,u),(8,i),(9,e),(9,u)\}

⸻

示例 2
	•	E = \{Bao, Charles, Cheng, Suzanne, Li, Pierre\}

定义关系 @：
若 a 喜欢 b，则 a @ b。

例如：
\{(Bao,Pierre),(Charles,Suzanne),(Suzanne,Pierre),(Charles,Li),(Li,Cheng),(Pierre,Bao)\}

可以说：
	•	Charles 喜欢 Suzanne
	•	但 Suzanne 不喜欢 Charles
⇒ 该关系 不是对称的

⸻

关系的扩展概念
	•	一个关系可以有：
	•	名字（nom）（如 amour）
	•	符号（symbole）（如 R 或 @）
	•	若关系定义在同一集合 E 上（E 到 E），称为自反关系 / 内关系（endorrelation）
	•	自关系可能具有的性质：
	•	自反性（réflexivité）
	•	对称性（symétricité）
	•	传递性（transitivité）

⸻

函数（Function）

函数 f : E \to F 是一种特殊关系：
	•	每个 a \in E 最多对应一个 b \in F

可能具有的性质：
	•	单射（injective）
	•	满射（surjective）

⸻

二、C++ 设计要求概述

类 relation<A,B>
	•	用于表示集合 set<A> 与 set<B> 之间的关系
	•	是一个类模板

成员数据
	•	聚合（aggregation）：
	•	const set<A>* source
	•	const set<B>* destination
	•	组合（composition）：
	•	set<pair<A,B>> couples
	•	其他：
	•	string nom
	•	string symbole

成员函数
	•	构造函数：接收名称、符号、源集合、目标集合（均为 const&）
	•	ajouter(a,b)：向关系中添加 (a,b)
	•	est_en_relation(a,b)：判断 (a,b) 是否在关系中
	•	访问器：
	•	get_nom()
	•	get_symbole()
	•	get_source()
	•	get_destination()

⸻

三、题目问题（Questions）

⸻

问题 1

解释：
	1.	为什么关系的源集合和目标集合是**聚合（aggregation）**而不是组合？
	2.	为什么关系中的有序对 (a,b) 是**组合（composition）**而不是聚合？

⸻

问题 2

哪些类需要（重新）定义以下方法？为什么？
	•	est_en_relation
	•	ajouter

⸻

问题 3

relation 类的属性应该使用哪种可见性？
	•	public
	•	private
	•	protected

请解释理由。

⸻

问题 4

给出 类 relation 的完整定义：
	•	声明所有属性和方法
	•	在类内只定义 访问器
	•	在类外定义：
	•	构造函数
	•	ajouter
	•	est_en_relation
	•	注意遵守里氏替换原则
	•	ajouter 应为 virtual
	•	析构函数应为 virtual

⸻

问题 5

给出 类 endorrelation（自关系） 的完整定义：
	•	声明所有属性和方法
	•	在类外定义构造函数
	•	定义 est_symetrique
	•	只有在必要时才重定义 ajouter

⸻

问题 6

给出 类 function（函数关系） 的完整定义：
	•	声明所有属性和方法
	•	只在必要时定义：
	•	构造函数
	•	ajouter
	•	ajouter 若违反“函数”特性（一个源对应多个目标），需抛异常

⸻

问题 7

使用 适配器模式（Adapter Pattern），
基于 set<pair<A,B>>::const_iterator，
为 relation 实现一个 迭代器 relation<A,B>::iterator，
以便顺序遍历关系中的所有 (a,b)。

并说明使用的是：
	•	类适配器
	•	还是 对象适配器

⸻

问题 8

重载运算符 <<，
使得可以将 relation / endorrelation / function
输出到 ostream，
并使用上一题中定义的 iterator。

⸻