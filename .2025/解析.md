# 三种继承模式区别
首先明确，基类中只有 public, protected 能被派生类继承，基类的private成员是无法被继承的

继承模式其实决定了基类的可继承成员（public, protected）在派生类对象中对外的访问级别

1. public
    基类中 public, protected 继承之后仍然是对应的级别

2. protected
    public, protected 都-> protected

3. private
    public, protected 都-> private全部私有化

## is-a关系
Derived is a base 派生类是一个基类
在任何需要 Base基类的地方，都可以安全使用 Derived派生类
```
Base* p = new Derived();
```

## adaptor模式基本都是private继承 ，而不是is-a
因为 适配器“用”被适配类，而不是“是”被适配类
private 私有化：用这个类实现自己，而不需要暴露它


# 泛型实现：（TS是写在旁边，C++是写在上方）
    ```
    template <typename T>
    class Container
    ```
    ```
    template <typename T>
    class Vector : public Container<T>
    ```
    对应的UML图的右上角会有一个 虚线框 :T

    

# adaptor 适配模式
例如前端对后端返回数据做转换而做的胶水层

# Template 模版模式
基类、抽象类定义框架
细节实现交给子类决定

# iterator 迭代器模式
统一暴露遍历方式，不暴露内部

/*
设计模式	关键词
Decorator	动态增强
Adapter	接口转换
Bridge	抽象与实现分离
Composite	树结构统一处理
Facade	简化入口
Factory	封装创建
Builder	分步构建
Strategy	算法切换
Template Method	流程固定
Iterator	统一遍历
Visitor	扩展操作
Memento	状态回滚
*/